<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.5.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Kopieren',
      copy_success: 'Kopiert',
      copy_failure: 'Kopieren fehlgeschlagen'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="hl0rey&#39;s blog">
<meta property="og:url" content="http://hl0rey.github.io/page/3/index.html">
<meta property="og:site_name" content="hl0rey&#39;s blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hl0rey&#39;s blog">
  <link rel="canonical" href="http://hl0rey.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>hl0rey's blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hl0rey's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Navigationsleiste an/ausschalten">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <div id="posts" class="posts-expand">
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://hl0rey.github.io/2018/02/10/隐式地调用系统API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hl0rey's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/02/10/隐式地调用系统API/" class="post-title-link" itemprop="url">隐式地调用系统API</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建于：2018-02-10 19:55:54 / 更新于：20:14:29" itemprop="dateCreated datePublished" datetime="2018-02-10T19:55:54+08:00">2018-02-10</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/reverse/" itemprop="url" rel="index"><span itemprop="name">reverse</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="隐藏调用系统API"><a href="#隐藏调用系统API" class="headerlink" title="隐藏调用系统API"></a>隐藏调用系统API</h4><pre><code>如果直接调用API，在将程序逆向的时候就会直接显示出被调用的函数的名字，所以根据程序的功能，结合调试器给出的提示很容易的就能定位关键代码，从而破解程序，所以程序员就采取一定的办法来隐式地调用系统API．
</code></pre><ul>
<li><p>下边这种办法比较简单，毕竟还是可以通过LoadlLibrary(),GetProcAddress()这俩函数来判断程序用了什么函数，通过在GetProcessAddress上下一个条件断点（一般返回值放在EAX，参数直接推进栈），来记录，它获取过什么函数的地址即可．</p>
</li>
<li><p>示例代码：</p>
<pre><code>TCHAR DllName[MAX_PATH]=&quot;user32.dll&quot;;
TCHAR ImportedFunctionName[MAX_PATH]=&quot;MessageBoxA&quot;;
HANDLE hDllModule=NULL;
DWORD dwFunctionAddress=0;

hDllModule=LoadLibrary(DllName);    
(FARPROC)dwFunctionAddress=GetProcAddress(hDllModule,ImportedFunctionName);
((FARPROC)dwFunctionAddress)(NULL,OutputInfor,&quot;Info&quot;,MB_OK | MB_ICONINFORMATION);
</code></pre></li>
<li><p>手动实现call指令方式，让调试器认不出call，如果开发者所有的API的这么调用，也算有恒心有毅力的了，放过他吧．</p>
</li>
<li><p>实例代码：</p>
<pre><code>_asm
{
            push MB_OK
            push StringAddress
            mov eax,0
            push eax
            push eax

            mov eax,offset Label
            push eax
            jmp [dwFunctionAddress]                //call MessageBox()
label:    
            nop
            nop
}
</code></pre></li>
</ul>
<p>以上代码段中的</p>
<pre><code>mov eax,offset Label001
push eax
jmp [dwFunctionAddress]       
</code></pre><p>实现了CALL 指令的功能，且功能有所增强，如果使用CALL 指令，API函数的返回地址必定是紧接CALL 指令的下一条指令的地址。<br>而此代码段可返回到任意指定地址，形成更具迷惑性的代码。</p>
<ul>
<li>动态解密函数名，感觉应该不如第二有迷惑性，找到动态解密函数的代码段即可了．<br>代码实例不好找</li>
</ul>
<p>参考链接：</p>
<pre><code>https://bbs.pediy.com/thread-73398.htm
</code></pre>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://hl0rey.github.io/2018/02/10/反调试之检测进程名/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hl0rey's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/02/10/反调试之检测进程名/" class="post-title-link" itemprop="url">反调试之检测进程名</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建于：2018-02-10 11:01:26 / 更新于：21:05:26" itemprop="dateCreated datePublished" datetime="2018-02-10T11:01:26+08:00">2018-02-10</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/reverse/" itemprop="url" rel="index"><span itemprop="name">reverse</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>通过遍历进程列表，读取所有进程名，一旦发现黑名单上的进程名，打开它的进程，获得他的句柄，并且关闭它．</p>
<h4 id="涉及的API"><a href="#涉及的API" class="headerlink" title="涉及的API"></a>涉及的API</h4><ul>
<li>EnumProcesses<br>枚举所有的进程PID（进程标识符）<br><a href="http://www.baike.com/wiki/EnumProcesses&amp;prd=button_doc_jinru" target="_blank" rel="noopener">互动百科－EnumProcesses</a> </li>
</ul>
<pre><code>函数往一个数组传入当前所有PID．然后遍历这个数组就可以遍历整个进程列表了
</code></pre><ul>
<li><p>EnumProcessModules<br>获取某进程里所有模块的句柄<br><a href="https://msdn.microsoft.com/zh-cn/ms682631\(v=vs.85\" target="_blank" rel="noopener">MSDN-EnumProcessModule</a>.aspx) </p>
<pre><code>函数往一个数组里放入某个进程所有模块的句柄．
</code></pre></li>
<li><p>GetModuleBaseName<br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms683196\(v=vs.85\" target="_blank" rel="noopener">MSDN-GetModuleBaseName</a>.aspx)<br>获得指定模块的名称，在Win32环境下，模块和进程可以混同．</p>
</li>
</ul>
<pre><code>函数向指定的缓冲区写入模块的名称．
</code></pre><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms682623\(v=vs.85\" target="_blank" rel="noopener">MSDN-EnumProcesses &amp; EnumProcessModule &amp; GetModuleBaseName 枚举所有进程</a>.aspx) </p>
<p>此外，个人用这种方式来实现遍历进程，涉及的API： CreateToolhelp32Snapshot<br><a href="https://msdn.microsoft.com/zh-cn/library/ms686852\(v=vs.85\" target="_blank" rel="noopener">MSDN-拍摄进程快照，再遍历进程</a>.aspx) </p>
<h4 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h4><p>在涉及的函数上下断点分析，修改程序内建的进程名黑名单，或者修改调试器的名称皆可．</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://hl0rey.github.io/2018/02/08/150行代码写成的可扩展的代码审计辅助工具/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hl0rey's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/02/08/150行代码写成的可扩展的代码审计辅助工具/" class="post-title-link" itemprop="url">150行代码写成的可扩展的代码审计辅助工具</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建于：2018-02-08 19:18:51 / 更新于：19:20:38" itemprop="dateCreated datePublished" datetime="2018-02-08T19:18:51+08:00">2018-02-08</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>你是否觉得有时候人类的思考模式很像正则匹配？
</code></pre><h4 id="本文包括以下几个部分："><a href="#本文包括以下几个部分：" class="headerlink" title="本文包括以下几个部分："></a>本文包括以下几个部分：</h4><pre><code>为什么我觉得可以用这个工具（个人认为）
我为什么写这个工具
工具的实现思路
工具的升级思路
源代码的github地址
使用测试
最后说两句
</code></pre><h4 id="为什么我觉得可以用这个工具（个人认为）"><a href="#为什么我觉得可以用这个工具（个人认为）" class="headerlink" title="为什么我觉得可以用这个工具（个人认为）"></a>为什么我觉得可以用这个工具（个人认为）</h4><pre><code>通过审计源代码，也就是查看源代码，来发现其中存在的隐患，代码审计需要对被审计的语言有充分的了解，不仅是能读懂源代码，还要了解语言本身的缺陷。很多时候代码审计的突破口就在于一些已经广为人知的有问题的代码的写法。如果能够快速找到突破口，也就提高了审计的效率。
</code></pre><h4 id="我为什么写这个工具"><a href="#我为什么写这个工具" class="headerlink" title="我为什么写这个工具"></a>我为什么写这个工具</h4><pre><code>我是一个ctf小白，为了考pte，正在学习怎么做ctf题目（个人比较感兴趣代码审计的题目，别的没啥什么感觉）。学习知识肯定是要笔记的，但是我觉得那种传统的笔记效果不是太好，记下来了也不一定记住了，到时候遇上题目万一想不起来，多尴尬。这时我忽然想到，我让程序记住就好了，它不会背叛我，一定会忠实地对我表达他的所见所想。所以我只要让程序看到某个字眼，就来提示我一下，并且告诉我，我把笔记记在了什么地方不就行了。
</code></pre><h4 id="工具的实现思路"><a href="#工具的实现思路" class="headerlink" title="工具的实现思路"></a>工具的实现思路</h4><pre><code>程序入口：adcode.py
主程序：ADC/ADCode.py
插件目录：rules
笔记目录（可选）：note
</code></pre><p><img src="/2018/02/08/150行代码写成的可扩展的代码审计辅助工具/adcode1.jpg" alt=""></p>
<h5 id="1-读取目标代码"><a href="#1-读取目标代码" class="headerlink" title="1.读取目标代码"></a>1.读取目标代码</h5><pre><code>联想平时的应用，我觉得应该让工具从剪贴板内读取待审计的代码，这样使用比较方便。但是，偶尔也会遇到待审计的代码是一个php文件的场景。所以我决定支持两种读取方式，一种是从剪贴板读取，一种是从文件读取。
</code></pre><p>剪贴板读取，为了能够跨平台，这里需要用到一个python的库——pyperclip。<br>这是一个第三方的跨平台的python访问剪贴板的库。<br>进入python shell看一下最基本的使用例子。</p>
<p><img src="/2018/02/08/150行代码写成的可扩展的代码审计辅助工具/1.png" alt=""></p>
<p>知道了这个库的使用，只需在代码中用其paste()方法，即可获取剪贴板的内容了。<br>从文件获取比较简单，直接用python的open()就好了。</p>
<h5 id="2-运行主程序"><a href="#2-运行主程序" class="headerlink" title="2.运行主程序"></a>2.运行主程序</h5><pre><code>让入口脚本调用主程序，把读取到的代码和插件的内容传递过去。
</code></pre><h5 id="3-加载插件"><a href="#3-加载插件" class="headerlink" title="3.加载插件"></a>3.加载插件</h5><pre><code>主程序加载插件，借助BeautifulSoup来解析插件内容。
插件有三种类型：
    1.vulnfunc 只要发现在程序中使用了某函数，则程序认为存在风险。
    2.regmatchall 根据插件给出的一条或者多条正则表达式，只有给出的正则全部能够匹配，才认为存在风险。
    3.regmatchonce 给出的一条或者多条正则表达式，只要有一条可以匹配，就认为存在风险。
    4.keywords 只要在代码中发现了关键词就认为有风险，简单粗暴。
</code></pre><h5 id="4-返回结果"><a href="#4-返回结果" class="headerlink" title="4.返回结果"></a>4.返回结果</h5><pre><code>根据插件的指示来分析代码，并且返回结果。
</code></pre><h5 id="5-格式化输出"><a href="#5-格式化输出" class="headerlink" title="5.格式化输出"></a>5.格式化输出</h5><pre><code>比较好看的把提示输出出来．
</code></pre><h4 id="工具的升级思路"><a href="#工具的升级思路" class="headerlink" title="工具的升级思路"></a>工具的升级思路</h4><pre><code>如果要审计大量的代码，则加入多线程机制，每个线程是一个插件，遍历指定的文件夹，挨个审计即可．
</code></pre><h4 id="源代码的github地址（我添加了尽量详尽的注释）"><a href="#源代码的github地址（我添加了尽量详尽的注释）" class="headerlink" title="源代码的github地址（我添加了尽量详尽的注释）"></a>源代码的github地址（我添加了尽量详尽的注释）</h4><pre><code>https://github.com/hl0rey/ADCode
</code></pre><h4 id="使用测试"><a href="#使用测试" class="headerlink" title="使用测试"></a>使用测试</h4><p>用这个地址的题目来测试，这些题目我觉得很典型很不错．<br><a href="https://github.com/bowu678/php_bugs" target="_blank" rel="noopener">https://github.com/bowu678/php_bugs</a></p>
<p>复制这个题目到剪贴板<br><img src="/2018/02/08/150行代码写成的可扩展的代码审计辅助工具/2.png" alt=""></p>
<p>直接运行脚本<br><img src="/2018/02/08/150行代码写成的可扩展的代码审计辅助工具/3.png" alt=""></p>
<p>输出内容如下<br><img src="/2018/02/08/150行代码写成的可扩展的代码审计辅助工具/4.png" alt=""></p>
<h4 id="最后说两句"><a href="#最后说两句" class="headerlink" title="最后说两句"></a>最后说两句</h4><p>１．我不知道这能不能算个代码审计工具，我姑且这么叫它，请各位大神轻喷．<br>２．这个工具的功能强大与否在于插件写的怎么样，是不是准确的把代码的问题用正则概括出来是关键．<br>３．希望能起到抛砖引玉的作用，分享思路．<br>４．也希望刚学习ｐｙｔｈｏｎ的新手，根据这篇文档和代码的注释能够学到东西．<br>５．一切尽在代码中．</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://hl0rey.github.io/2018/02/08/网页表单调用以外的钓鱼方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hl0rey's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/02/08/网页表单调用以外的钓鱼方法/" class="post-title-link" itemprop="url">网页表单调用以外的钓鱼方法</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建于：2018-02-08 19:12:52 / 更新于：19:15:04" itemprop="dateCreated datePublished" datetime="2018-02-08T19:12:52+08:00">2018-02-08</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tools/" itemprop="url" rel="index"><span itemprop="name">tools</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>所有渗透中有趣的思路，那都是渗透的艺术。
                            ——（中）沃兹基索德
</code></pre><h2 id="钓鱼式攻击"><a href="#钓鱼式攻击" class="headerlink" title="钓鱼式攻击"></a>钓鱼式攻击</h2><p>顾名思义，是一种如同钓鱼一样的攻击，是一种安逸的很的攻击方式。<br>搜狗百科是给出来比较容易理解的网络钓鱼的定义。</p>
<pre><code>网络钓鱼 （Phishing）攻击者利用欺骗性的电子邮件和伪造的 Web 站点来进行网络诈骗活动，受骗者往往会泄露自己的私人资料，如信用卡号、银行卡账户、身份证号等内容。诈骗者通常会将自己伪装成网络银行、在线零售商和信用卡公司等可信的品牌，骗取用户的私人信息
</code></pre><p>可以看出，钓鱼攻击并不是一种完全随缘的攻击方法。关键在于是否成功伪装成了受害者信任的目标。</p>
<h2 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h2><p>现在你接受了一项秘密任务，组织需要你拿到X公司服务上的一份秘密的名单，然而X公司是一家非常有钱的公司，聘请了专业的打补丁的人员，服务器该有的补丁都有了，还有专业的web扫描器使用者，天天对他们的网站进行扫描，你手中也没有0day。但是唯一可喜的是你可以进入他的内网（这就是所谓的百密一疏吧）。</p>
<pre><code>假设现在你已经成功欺骗了受害者的机器，他已经认为你就是目标服务器。
</code></pre><p><img src="/2018/02/08/网页表单调用以外的钓鱼方法/msffish.png" alt="image"></p>
<pre><code>msf可以说是当下最强大渗透测试框架，是一个渗透测试者必须掌握的神器。
                                                ——（中）耶斯沃兹基索德
</code></pre><h5 id="X公司管理员特别喜欢用ftp管理服务器（不要在意他为什么喜欢用ftp，这是剧情需要）。"><a href="#X公司管理员特别喜欢用ftp管理服务器（不要在意他为什么喜欢用ftp，这是剧情需要）。" class="headerlink" title="X公司管理员特别喜欢用ftp管理服务器（不要在意他为什么喜欢用ftp，这是剧情需要）。"></a>X公司管理员特别喜欢用ftp管理服务器（不要在意他为什么喜欢用ftp，这是剧情需要）。</h5><p>在做事之前，我们得把假的ftp服务器运行起来。<br><img src="/2018/02/08/网页表单调用以外的钓鱼方法/1.png" alt="image"></p>
<p>默认配置即可，或者你想改变的个端口也可以。<br><img src="/2018/02/08/网页表单调用以外的钓鱼方法/2.png" alt="image"></p>
<p>如果端口没有被占用并且权限够大，就能看到如下界面，ftp凭证收割机就启动了。<br><img src="/2018/02/08/网页表单调用以外的钓鱼方法/3.png" alt="image"></p>
<p>通过社会工程学的方法，冒充客服妹子等等，比如，“管理员小哥哥，有个小黑客跟我说，他在在我们服务器web根目录上传shell了，他好厉害啊。”。这样刺激了管理员的雄性荷尔蒙，他就想上去服务器看看了。</p>
<p>管理员受到了刺激，登录ftp，但是他受到了更大的刺激，“难道真的被黑了？”<br><img src="/2018/02/08/网页表单调用以外的钓鱼方法/5.png" alt="image"></p>
<p>再看我们这边，我们已经成功。<br><img src="/2018/02/08/网页表单调用以外的钓鱼方法/6.png" alt="image"><br><img src="/2018/02/08/网页表单调用以外的钓鱼方法/7.png" alt="image"></p>
<p>使用creds命令，查看我们收集到的凭证。<br><img src="/2018/02/08/网页表单调用以外的钓鱼方法/8.png" alt="image"></p>
<p>最后完美收网，停止欺骗攻击，管理员最终登录上了ftp服务器，并且没有发现上传shell，截图给妹子看，获得了妹子的亲睐，并且约好了晚上一起吃饭（管理员并不知道妹子也是假的）。我们把管理员约到一个偏远地区，我们就可以趁机上传shell了。</p>
<pre><code>真是一次精彩的作战。
</code></pre><p>msf还有其他的创建为了收集用户凭证的虚假服务的模块。</p>
<pre><code>截止2017年12月26号，可用的模块有
     auxiliary/server/capture/drda    分布式关系数据库体系结构（百度百科的解释）
     auxiliary/server/capture/ftp
     auxiliary/server/capture/http
     auxiliary/server/capture/http_basic
     auxiliary/server/capture/http_javascript_keylogger
     auxiliary/server/capture/http_ntlm
     auxiliary/server/capture/imap
     auxiliary/server/capture/mssql
     auxiliary/server/capture/mysql
     auxiliary/server/capture/pop3
     auxiliary/server/capture/postgresql
     auxiliary/server/capture/printjob_capture
     auxiliary/server/capture/sip
     auxiliary/server/capture/smb
     auxiliary/server/capture/smtp
     auxiliary/server/capture/telnet
     auxiliary/server/capture/vnc
</code></pre><p>只要思路到位就可以玩出花来，让受害者不知道到底在哪一步上当了。</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://hl0rey.github.io/2018/02/08/反调试之IsDebuggerPresent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hl0rey's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/02/08/反调试之IsDebuggerPresent/" class="post-title-link" itemprop="url">反调试之IsDebuggerPresent</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建于：2018-02-08 17:19:20 / 更新于：19:05:32" itemprop="dateCreated datePublished" datetime="2018-02-08T17:19:20+08:00">2018-02-08</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/reverse/" itemprop="url" rel="index"><span itemprop="name">reverse</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="函数功能"><a href="#函数功能" class="headerlink" title="函数功能"></a>函数功能</h3><ul>
<li>IsDebuggerPresent 函数</li>
</ul>
<pre><code>确定调用进程是否由用户模式(ring 3)的调试器调试。
</code></pre><ul>
<li><p>语法</p>
<pre><code>BOOL WINAPI IsDebuggerPresent(void);
</code></pre></li>
<li><p>参数</p>
<pre><code>该函数没有参数
</code></pre></li>
<li><p>返回值</p>
<pre><code>如果当前进程运行在调试器的上下文，返回值为非零值。
如果当前进程没有运行在调试器的上下文，返回值是零。
返回值放在EAX
</code></pre></li>
<li><p>对应的汇编代码</p>
<pre><code>mov eax,dword ptr fs:[0x18]
mov eax,dword ptr ds:[eax+0x30]
movzx eax,byte ptr ds:[eax+0x2]
</code></pre></li>
</ul>
<h3 id="为什么是fs-0x18"><a href="#为什么是fs-0x18" class="headerlink" title="为什么是fs:[0x18]"></a>为什么是fs:[0x18]</h3><pre><code>fs:[0]的值即为TEB的起始地址。
</code></pre><h4 id="TEB-Thread-Environment-Block，线程环境块"><a href="#TEB-Thread-Environment-Block，线程环境块" class="headerlink" title="TEB(Thread Environment Block，线程环境块)"></a>TEB(Thread Environment Block，线程环境块)</h4><pre><code>线程环境块中存放着进程中所有线程的各种信息
</code></pre><h4 id="TEB-数据结构"><a href="#TEB-数据结构" class="headerlink" title="TEB 数据结构"></a>TEB 数据结构</h4><pre><code>nt!_TEB
   +0x000 NtTib            : _NT_TIB
   +0x01c EnvironmentPointer : Ptr32 Void
   +0x020 ClientId         : _CLIENT_ID
   +0x028 ActiveRpcHandle  : Ptr32 Void
   +0x02c ThreadLocalStoragePointer : Ptr32 Void
   +0x030 ProcessEnvironmentBlock : Ptr32 _PEB
   +0x034 LastErrorValue   : Uint4B
   +0x038 CountOfOwnedCriticalSections : Uint4B
   +0x03c CsrClientThread  : Ptr32 Void
   +0x040 Win32ThreadInfo  : Ptr32 Void
   +0x044 User32Reserved   : [26] Uint4B
   +0x0ac UserReserved     : [5] Uint4B
   +0x0c0 WOW32Reserved    : Ptr32 Void
   +0x0c4 CurrentLocale    : Uint4B
   +0x0c8 FpSoftwareStatusRegister : Uint4B
   +0x0cc SystemReserved1  : [54] Ptr32 Void
   +0x1a4 ExceptionCode    : Int4B
   +0x1a8 ActivationContextStack : _ACTIVATION_CONTEXT_STACK
   +0x1bc SpareBytes1      : [24] UChar
   +0x1d4 GdiTebBatch      : _GDI_TEB_BATCH
   +0x6b4 RealClientId     : _CLIENT_ID
   +0x6bc GdiCachedProcessHandle : Ptr32 Void
   +0x6c0 GdiClientPID     : Uint4B
   +0x6c4 GdiClientTID     : Uint4B
   +0x6c8 GdiThreadLocalInfo : Ptr32 Void
   +0x6cc Win32ClientInfo  : [62] Uint4B
   +0x7c4 glDispatchTable  : [233] Ptr32 Void
   +0xb68 glReserved1      : [29] Uint4B
   +0xbdc glReserved2      : Ptr32 Void
   +0xbe0 glSectionInfo    : Ptr32 Void
   +0xbe4 glSection        : Ptr32 Void
   +0xbe8 glTable          : Ptr32 Void
   +0xbec glCurrentRC      : Ptr32 Void
   +0xbf0 glContext        : Ptr32 Void
   +0xbf4 LastStatusValue  : Uint4B
   +0xbf8 StaticUnicodeString : _UNICODE_STRING
   +0xc00 StaticUnicodeBuffer : [261] Uint2B
   +0xe0c DeallocationStack : Ptr32 Void
   +0xe10 TlsSlots         : [64] Ptr32 Void
   +0xf10 TlsLinks         : _LIST_ENTRY
   +0xf18 Vdm              : Ptr32 Void
   +0xf1c ReservedForNtRpc : Ptr32 Void
   +0xf20 DbgSsReserved    : [2] Ptr32 Void
   +0xf28 HardErrorsAreDisabled : Uint4B
   +0xf2c Instrumentation  : [16] Ptr32 Void
   +0xf6c WinSockData      : Ptr32 Void
   +0xf70 GdiBatchCount    : Uint4B
   +0xf74 InDbgPrint       : UChar
   +0xf75 FreeStackOnTermination : UChar
   +0xf76 HasFiberData     : UChar
   +0xf77 IdealProcessor   : UChar
   +0xf78 Spare3           : Uint4B
   +0xf7c ReservedForPerf  : Ptr32 Void
   +0xf80 ReservedForOle   : Ptr32 Void
   +0xf84 WaitingOnLoaderLock : Uint4B
   +0xf88 Wx86Thread       : _Wx86ThreadState
   +0xf94 TlsExpansionSlots : Ptr32 Ptr32 Void
   +0xf98 ImpersonationLocale : Uint4B
   +0xf9c IsImpersonating  : Uint4B
   +0xfa0 NlsCache         : Ptr32 Void
   +0xfa4 pShimData        : Ptr32 Void
   +0xfa8 HeapVirtualAffinity : Uint4B
   +0xfac CurrentTransactionHandle : Ptr32 Void
   +0xfb0 ActiveFrame      : Ptr32 _TEB_ACTIVE_FRAME
   +0xfb4 SafeThunkCall    : UChar
   +0xfb5 BooleanSpare     : [3] UChar
</code></pre><h4 id="TEB的结构体的第一个成员NtTib"><a href="#TEB的结构体的第一个成员NtTib" class="headerlink" title="TEB的结构体的第一个成员NtTib"></a>TEB的结构体的第一个成员NtTib</h4><pre><code>即为我们常说的TIB（Thread Information Block，线程信息块）
</code></pre><h4 id="TIB数据结构"><a href="#TIB数据结构" class="headerlink" title="TIB数据结构"></a>TIB数据结构</h4><pre><code>typedef struct _NT_TIB          //sizeof  1ch  
{  
 00h   struct _EXCEPTION_REGISTRATION_RECORD  *ExceptionList; 
 04h   PVOID                            StackBase;
 08h   PVOID                            StackLimit;
 0ch   PVOID                            SubSystemTib;  
       union {  
       PVOID                FiberData;  
 10h       DWORD                Version;  
       };  
 14h   PVOID                            ArbitraryUserPointer;  
 18h   struct _NT_TIB                   *Self; 
}NT_TIB;  
</code></pre><h4 id="PEB的数据结构"><a href="#PEB的数据结构" class="headerlink" title="PEB的数据结构"></a>PEB的数据结构</h4><pre><code>nt!_PEB
   +0x000 InheritedAddressSpace : UChar
   +0x001 ReadImageFileExecOptions : UChar
   +0x002 BeingDebugged    : UChar
   +0x003 SpareBool        : UChar
   +0x004 Mutant           : Ptr32 Void
   +0x008 ImageBaseAddress : Ptr32 Void
   +0x00c Ldr              : Ptr32 _PEB_LDR_DATA
   +0x010 ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS
   +0x014 SubSystemData    : Ptr32 Void
   +0x018 ProcessHeap      : Ptr32 Void
   +0x01c FastPebLock      : Ptr32 _RTL_CRITICAL_SECTION
   +0x020 FastPebLockRoutine : Ptr32 Void
   +0x024 FastPebUnlockRoutine : Ptr32 Void
   +0x028 EnvironmentUpdateCount : Uint4B
   +0x02c KernelCallbackTable : Ptr32 Void
   +0x030 SystemReserved   : [1] Uint4B
   +0x034 AtlThunkSListPtr32 : Uint4B
   +0x038 FreeList         : Ptr32 _PEB_FREE_BLOCK
   +0x03c TlsExpansionCounter : Uint4B
   +0x040 TlsBitmap        : Ptr32 Void
   +0x044 TlsBitmapBits    : [2] Uint4B
   +0x04c ReadOnlySharedMemoryBase : Ptr32 Void
   +0x050 ReadOnlySharedMemoryHeap : Ptr32 Void
   +0x054 ReadOnlyStaticServerData : Ptr32 Ptr32 Void
   +0x058 AnsiCodePageData : Ptr32 Void
   +0x05c OemCodePageData  : Ptr32 Void
   +0x060 UnicodeCaseTableData : Ptr32 Void
   +0x064 NumberOfProcessors : Uint4B
   +0x068 NtGlobalFlag     : Uint4B
   +0x070 CriticalSectionTimeout : _LARGE_INTEGER
   +0x078 HeapSegmentReserve : Uint4B
   +0x07c HeapSegmentCommit : Uint4B
   +0x080 HeapDeCommitTotalFreeThreshold : Uint4B
   +0x084 HeapDeCommitFreeBlockThreshold : Uint4B
   +0x088 NumberOfHeaps    : Uint4B
   +0x08c MaximumNumberOfHeaps : Uint4B
   +0x090 ProcessHeaps     : Ptr32 Ptr32 Void
   +0x094 GdiSharedHandleTable : Ptr32 Void
   +0x098 ProcessStarterHelper : Ptr32 Void
   +0x09c GdiDCAttributeList : Uint4B
   +0x0a0 LoaderLock       : Ptr32 Void
   +0x0a4 OSMajorVersion   : Uint4B
   +0x0a8 OSMinorVersion   : Uint4B
   +0x0ac OSBuildNumber    : Uint2B
   +0x0ae OSCSDVersion     : Uint2B
   +0x0b0 OSPlatformId     : Uint4B
   +0x0b4 ImageSubsystem   : Uint4B
   +0x0b8 ImageSubsystemMajorVersion : Uint4B
   +0x0bc ImageSubsystemMinorVersion : Uint4B
   +0x0c0 ImageProcessAffinityMask : Uint4B
   +0x0c4 GdiHandleBuffer  : [34] Uint4B
   +0x14c PostProcessInitRoutine : Ptr32     void 
   +0x150 TlsExpansionBitmap : Ptr32 Void
   +0x154 TlsExpansionBitmapBits : [32] Uint4B
   +0x1d4 SessionId        : Uint4B
   +0x1d8 AppCompatFlags   : _ULARGE_INTEGER
   +0x1e0 AppCompatFlagsUser : _ULARGE_INTEGER
   +0x1e8 pShimData        : Ptr32 Void
   +0x1ec AppCompatInfo    : Ptr32 Void
   +0x1f0 CSDVersion       : _UNICODE_STRING
   +0x1f8 ActivationContextData : Ptr32 Void
   +0x1fc ProcessAssemblyStorageMap : Ptr32 Void
   +0x200 SystemDefaultActivationContextData : Ptr32 Void
   +0x204 SystemAssemblyStorageMap : Ptr32 Void
   +0x208 MinimumStackCommit : Uint4B
</code></pre><h4 id="汇编代码分析"><a href="#汇编代码分析" class="headerlink" title="汇编代码分析"></a>汇编代码分析</h4><pre><code>mov eax,dword ptr fs:[0x18]
;取TIB中的*self，也就是取指向自己的指针，也是指向TEB的指针
mov eax,dword ptr ds:[eax+0x30]
;取Ptr32 _PEB的值，就是指向PEB的指针
movzx eax,byte ptr ds:[eax+0x2]
;取PEB中的BeingDebugged，来判断进程是否被调试．非0即真．
</code></pre><h4 id="反反调试"><a href="#反反调试" class="headerlink" title="反反调试"></a>反反调试</h4><pre><code>直接把IsDebuggerPresent函数去掉，或者修改PEB中BeingDebugged的值皆可绕过．
</code></pre>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://hl0rey.github.io/2018/02/07/php代码审计思维导图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hl0rey's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/02/07/php代码审计思维导图/" class="post-title-link" itemprop="url">php代码审计思维导图</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建于：2018-02-07 22:38:10 / 更新于：22:39:06" itemprop="dateCreated datePublished" datetime="2018-02-07T22:38:10+08:00">2018-02-07</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://raw.githubusercontent.com/SecWiki/sec-chart/master/Web%E5%AE%89%E5%85%A8/PHP%E6%BA%90%E7%A0%81%E5%AE%A1%E8%AE%A1.png" alt=""> </p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://hl0rey.github.io/2018/02/07/OD中的各种断点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hl0rey's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/02/07/OD中的各种断点/" class="post-title-link" itemprop="url">OD中的各种断点</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建于：2018-02-07 21:27:49" itemprop="dateCreated datePublished" datetime="2018-02-07T21:27:49+08:00">2018-02-07</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="更新于：2018-02-08 17:17:35" itemprop="dateModified" datetime="2018-02-08T17:17:35+08:00">2018-02-08</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/reverse/" itemprop="url" rel="index"><span itemprop="name">reverse</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="普通断点"><a href="#普通断点" class="headerlink" title="普通断点"></a>普通断点</h3><p>又叫F2断点,或者CC断点，或者INT3断点．<br>按F2设置普通断点，所以叫F2断点．<br>叫CC断点的原因是OD会在设置断点的位置之前（此处抱有疑问），写入一个CC，引发INT3中断，所以也叫INT3断点．</p>
<h3 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h3><p>本质是修改某块内存的属性，让程序在访问目标内存的时候，触发异常，被OD捕获，进而成功断下程序．在一些比较难以确定在哪个API下断点的时候，内存断点有奇效．</p>
<h3 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h3><p>这是计算机硬件提供给我们的功能．<br>硬件断点和DRx调试寄存器有关。从Inter CPU体系架构手册中，可以找到DRx调试寄存器的介绍。<br>　　DRx调试寄存器总共有8个，从DRx0到DRx7。每个寄存器的特性如下：<br>　　·DR0－DR3：调试 地址寄存器，保存需要监视的地址，如设置硬件断点；<br>　　·DR4－DR5：保留，未公开具体作用；<br>　　·DR6：调试 寄存器组 状态寄存器；<br>　　·DR7：调试寄存器组 控制寄存器。<br>　　硬件断点原理是使用4个调试寄存器（DR0,DR1,DR2,DR3）来设定地址，以及DR7设定状态，比如：对这个401000是硬件读还是写，或者是执行；是对 字节还是对字，或者是双字。因此最多只能设置4个断点。<br>　　OllyDbg支持调试寄存器，其称为硬件断点。设置方法是在指定的代码行单击鼠标右键，执行设置断点、硬件执行命令。<br>　　硬件断点优点是速度快，在 INT3断点容易被发现的地方，使用硬件断点来代替会有很好的效果，缺点就是最多只能设置4个断点。 
　　</p>
<h3 id="API断点"><a href="#API断点" class="headerlink" title="API断点"></a>API断点</h3><p>本质是CC断点<br>ctrl + N 查找API</p>
<h6 id="按软件功能来猜测其使用了哪些API"><a href="#按软件功能来猜测其使用了哪些API" class="headerlink" title="按软件功能来猜测其使用了哪些API"></a>按软件功能来猜测其使用了哪些API</h6><h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>本质是一个CC断点（CC是红色，条件是粉色），选到某行，快捷键 shift + F2。弹出的框中输入条件，如 EAX==400000，EAX==400000 || ECX == 6，EAX==400000 &amp;&amp; ECX == 6，满足条件，就断。 </p>
<p>条件记录断点：shift + F4,该断点是用来记录东西的，点击工具栏L 已进入日志窗口</p>
<h6 id="在软件通过寄存器一位一位的对比注册码的时候有妙用"><a href="#在软件通过寄存器一位一位的对比注册码的时候有妙用" class="headerlink" title="在软件通过寄存器一位一位的对比注册码的时候有妙用"></a>在软件通过寄存器一位一位的对比注册码的时候有妙用</h6><h3 id="消息断点："><a href="#消息断点：" class="headerlink" title="消息断点："></a>消息断点：</h3><p>本质是一个条件断点。<br>拦截窗口或控件的消息。<br>点击工具栏的 W ，点击右键。 刷新，就会出现一些控件句柄，在claProc上右键，设置断点，选择需要中断的消息。</p>
<p>ESP 堆栈最顶端</p>
<p>[ESP+8] 堆栈中消息的位置</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://hl0rey.github.io/2018/02/06/PHP使用了PDO的情况下可能产生注入的情况/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hl0rey's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/02/06/PHP使用了PDO的情况下可能产生注入的情况/" class="post-title-link" itemprop="url">PHP使用了PDO的情况下可能产生注入的情况</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建于：2018-02-06 16:15:43" itemprop="dateCreated datePublished" datetime="2018-02-06T16:15:43+08:00">2018-02-06</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="更新于：2018-02-08 12:22:14" itemprop="dateModified" datetime="2018-02-08T12:22:14+08:00">2018-02-08</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="PDO-官方文档"><a href="#PDO-官方文档" class="headerlink" title="PDO 官方文档"></a>PDO 官方文档</h3><p><a href="http://php.net/manual/zh/book.pdo.php" target="_blank" rel="noopener">http://php.net/manual/zh/book.pdo.php</a></p>
<pre><code>对于做代码审计来说，遇到Pdo预编译，序列化查询基本上就可以对注入说再见了,我们有理由相信,一个网站,基本上全站都使用了序列化查询的情况下,是不可能在一些重要功能点使用拼接的方式进行SQL语句的查询,所以说这种漏洞应该是作者故意留的吧。　　
                                            --某前辈所言
</code></pre><h3 id="能防止注入的情况"><a href="#能防止注入的情况" class="headerlink" title="能防止注入的情况"></a>能防止注入的情况</h3><pre><code>&lt;?php
if (!isset($_GET[&apos;id&apos;])){
    die();
}
$dbh=new PDO(&apos;mysql:host=localhost;dbname=test_data&apos;,&apos;root&apos;,&apos;&apos;);
$sql=&quot;SELECT * FROM `users` WHERE `username`=:username&quot;;
$sth=$dbh-&gt;prepare($sql);
$sth-&gt;execute(array(&apos;:username&apos;=&gt;$_GET[&apos;id&apos;]));
$result=$sth-&gt;fetch(PDO::FETCH_ASSOC);
echo $result[&apos;id&apos;];
</code></pre><h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h3><p>Pdo直接使用query或者exec来执行sql语句时,由于没有预编译的过程所以没有起到防注入的作用．<br>1.用query的情况：</p>
<pre><code>&lt;?php
if (!isset($_GET[&apos;id&apos;])){
    die();
}

$dbh=new PDO(&apos;mysql:host=localhost;dbname=test_data&apos;,&apos;root&apos;,&apos;&apos;);
$sql=&quot;SELECT * FROM `users` WHERE `id`=&quot;.$_GET[&apos;id&apos;].&quot;;&quot;;

$result=$dbh-&gt;query($sql);
foreach ($result-&gt;fetch(PDO::FETCH_ASSOC) as $item) {

    echo $item;

}
foreach ($dbh-&gt;errorInfo() as $row){
    echo $row;
}
</code></pre><p>2.用exec的情况：</p>
<pre><code>&lt;?php
if (!isset($_GET[&apos;id&apos;])){
    die();
}

$dbh=new PDO(&apos;mysql:host=localhost;dbname=test_data&apos;,&apos;root&apos;,&apos;&apos;);
$sql=&quot;SELECT * FROM `users` WHERE `id`=&quot;.$_GET[&apos;id&apos;].&quot;;&quot;;

$result=$dbh-&gt;exec($sql);

echo $result;
</code></pre><h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><p>在sql语句预编译之前，修改了sql语句．<br>情况复杂的多，举两个典型的例子．<br>1.</p>
<pre><code>&lt;?php
if (!isset($_GET[&apos;id&apos;])){
    die();
}

$dbh=new PDO(&apos;mysql:host=localhost;dbname=test_data&apos;,&apos;root&apos;,&apos;&apos;);
$sql=&quot;SELECT * FROM `users` WHERE `id`=:&quot;.$_GET[&apos;id&apos;];
$sth=$dbh-&gt;prepare($sql);
$sth-&gt;execute(array(&quot;:id&quot;=&gt;1));
$result=$sth-&gt;fetch(PDO::FETCH_ASSOC);
foreach ($result as $item){
    echo $item;
}
</code></pre><p>2.<br>第一种情况加上第二种情况的第一个例子，产生的注入　sqlmap一把梭　就可以．<br>但是下面这种情形是不能用sqlmap一把梭的．</p>
<pre><code>&lt;?php

if (!isset($_GET[&apos;id&apos;])){
    die();
}

$dbh=new PDO(&apos;mysql:host=localhost;dbname=test_data&apos;,&apos;root&apos;,&apos;&apos;);
$sql=&quot;SELECT * FROM `&quot;.$_GET[&apos;id&apos;].&quot;` WHERE `username`=:name&quot;;
$sth=$dbh-&gt;prepare($sql);
$sth-&gt;execute(array(&quot;:name&quot;=&gt;&apos;admin&apos;));
$result=$sth-&gt;fetch(PDO::FETCH_ASSOC);
foreach ($result as $item){
    echo $item;
}
</code></pre><p>PDO预编译，预先编译一下，php会把sql语句先放到数据库去执行一下．<br>所以说，就算污染了sql语句，导致在预编译之后，无法传入变量，执行语句也没关系．因为在预编译之时，sql语句已经被执行了．</p>
<h4 id="监控mysql的语句执行记录"><a href="#监控mysql的语句执行记录" class="headerlink" title="监控mysql的语句执行记录"></a>监控mysql的语句执行记录</h4><p>这种注入可以说没有任何反映，我们要验证的时候，需要监控mysql的语句执行．</p>
<pre><code>在mysql命令行或者客户端管理工具中执行：SHOW VARIABLES LIKE     &quot;general_log%&quot;;

结果：
MariaDB [(none)]&gt; SHOW VARIABLES LIKE &quot;general_log%&quot;;
+------------------+----------+
| Variable_name    | Value    |
+------------------+----------+
| general_log      | OFF      |
| general_log_file | kali.log |
+------------------+----------+
2 rows in set (0.00 sec)


OFF说明没有开启日志记录

分别执行开启日志以及日志路径和日志文件名
SET GLOBAL general_log = &apos;ON&apos;;

默认日志文件位置    /var/lib/mysql/kali.log    

还要注意
这时执行的所有sql都会别记录下来，方便查看，但是如果重启mysql就会停止记录需要重新设置

然后执行　watch tail /var/lib/mysql/kali.log
</code></pre><p>开始监控．．．<br><img src="/2018/02/06/PHP使用了PDO的情况下可能产生注入的情况/1.png" alt=""> </p>
<p>然后就随便拼语句，看效果了．</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://hl0rey.github.io/2018/02/04/http协议详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hl0rey's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/02/04/http协议详解/" class="post-title-link" itemprop="url">http协议详解</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建于：2018-02-04 19:06:57" itemprop="dateCreated datePublished" datetime="2018-02-04T19:06:57+08:00">2018-02-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="更新于：2018-03-12 21:37:37" itemprop="dateModified" datetime="2018-03-12T21:37:37+08:00">2018-03-12</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HTTP协议详解"><a href="#HTTP协议详解" class="headerlink" title="HTTP协议详解"></a>HTTP协议详解</h1><p>HTTP 协议，即超文本传输协议(Hypertext transfer protocol)。 是一种<br>详细规定了浏览器和万维网(WWW = World Wide Web)服务器之间互相通信的规则，<br>通过因特网传送万维网文档的数据传送协议</p>
<h6 id="HTTP协议的特点就不好再赘述了"><a href="#HTTP协议的特点就不好再赘述了" class="headerlink" title="HTTP协议的特点就不好再赘述了"></a>HTTP协议的特点就不好再赘述了</h6><p>中文RFC文档：</p>
<p><a href="http://man.chinaunix.net/develop/rfc/RFC1945.txt" target="_blank" rel="noopener">超文本传输协议–HTTP1.0</a></p>
<pre><code>本文的主要内容：
    基础知识：
    HTTP 请求方法
        HTTP1.0 的请求方法
            了解 HTTP1.0 三种请求方法， GET, POST 和 HEAD
            掌握 GET 请求的标准格式
            掌握 POST 请求提交表单， 上传文件的方法
            了解 HEAD 请求与 GET 请求的区别
        HTTP1.1 新增的请求方法
            了解 HTTP1.1 新增了五种请求方法： OPTIONS, PUT, DELETE,TRACE 和 CONNECT 方法的基本概念
            掌握 HTTP1.1 新增的五种请求的基本方法和产生的请求结果

    HTTP 的状态码
        HTTP 状态码的分类
            了解 HTTP 状态码的规范
            了解 HTTP 状态码的作用
            掌握常见的 HTTP 状态码
        HTTP 状态码的含义
            了解 HTTP 状态码 2**,3**,4**,5** 代表的含义
            掌握用计算机语言获取 HTTP 状态码的方法

    HTTP 协议响应头信息
        HTTP 响应头的含义
            了解常见的 HTTP 响应头
            掌握 HTTP 响应头的作用
        HTTP 响应头的类型
            了解 HTTP 响应头的名称
            掌握 HTTP 响应头的格式

    HTTP 协议中的 URL
        URL 的基本构成
            了解 URL 的基本概念
            了解 URL 的结构
            掌握 URL 编码格式
        URL、URN和URI的区别

    扩展内容：
    HTTP2.0 新事物
    HTTP XST攻击与trace方法
    使用python requests库花式发送http请求（如果使用python的比较底层的HTTP请求库还能fuzzing）
    Web DAV（Web-based Distributed Authoring and Versioning）
    CRLF注入攻击
</code></pre><h2 id="HTTP的请求方法"><a href="#HTTP的请求方法" class="headerlink" title="HTTP的请求方法"></a>HTTP的请求方法</h2><p>一个HTTP请求结构</p>
<p><img src="http协议详解/1.png" alt=""> </p>
<h3 id="HTTP1-0-的请求方法"><a href="#HTTP1-0-的请求方法" class="headerlink" title="HTTP1.0 的请求方法"></a>HTTP1.0 的请求方法</h3><h4 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h4><p>请求指定的页面信息，并返回实体主体。</p>
<p>最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是GET方式。GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制。例如，/index.jsp?id=100&amp;op=bind,这样通过GET方式传递的数据直接表示在地址中，所以我们可以把请求结果以链接的形式发送给好友。以用google搜索domety为例，Request格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq= HTTP/1.1  </span><br><span class="line">Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, </span><br><span class="line">application/msword, application/x-silverlight, application/x-shockwave-flash, */*  </span><br><span class="line">Referer: &lt;a href=&quot;http://www.google.cn/&quot;&gt;http://www.google.cn/&lt;/a&gt;  </span><br><span class="line">Accept-Language: zh-cn  </span><br><span class="line">Accept-Encoding: gzip, deflate  </span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  </span><br><span class="line">Host: &lt;a href=&quot;http://www.google.cn&quot;&gt;www.google.cn&lt;/a&gt;  </span><br><span class="line">Connection: Keep-Alive  </span><br><span class="line">Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; </span><br><span class="line">NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-</span><br><span class="line">FxlRugatx63JLv7CWMD6UB_O_r</span><br></pre></td></tr></table></figure>
<p>可以看到，GET方式的请求一般不包含”请求内容”部分，请求数据以地址的形式表现在请求行。地址链接如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.google.cn/search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq=&quot;&gt;http://www.google.cn/search?hl=zh-CN&amp;source=hp</span><br><span class="line">&amp;q=domety&amp;aq=f&amp;oq=&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>地址中”?”之后的部分就是通过GET发送的请求数据，我们可以在地址栏中清楚的看到，各个数据之间用”&amp;”符号隔开。显然，这种方式不适合传送私密数据。另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，所以如果需要传送大量数据的时候，也不适合使用GET方式。</p>
<p>一个形象的比喻：</p>
<pre><code>HTTP报文和HTTP实体的关系就像订单信息和具体的订单货物一样。
HTTP报文是一个提供http头信息和主体的请求或响应，类似一个订单拥有订单的各种信息。
而HTTP实体就像订单的具体货物一样，他本身就持有头部和主体的信息，他是传输中真正传输的数据，和订单中传输的是订单商品一样
</code></pre><p>实体 entity 是请求或响应的有效承载信息。Http报头分为通用报头，请求报头，响应报头和实体报头。实体包头加上实体就是实体信息</p>
<p>GET 方法是获取服务器某一资源的方法。</p>
<h4 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h4><p>向服务器发送数据。</p>
<p>对于上面提到的不适合使用GET方式的情况，可以考虑使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。还以上面的搜索domety为例，如果使用POST方式的话，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /search HTTP/1.1  </span><br><span class="line">Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, </span><br><span class="line">application/msword, application/x-silverlight, application/x-shockwave-flash, */*  </span><br><span class="line">Referer: &lt;a href=&quot;http://www.google.cn/&quot;&gt;http://www.google.cn/&lt;/a&gt;  </span><br><span class="line">Accept-Language: zh-cn  </span><br><span class="line">Accept-Encoding: gzip, deflate  </span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  </span><br><span class="line">Host: &lt;a href=&quot;http://www.google.cn&quot;&gt;www.google.cn&lt;/a&gt;  </span><br><span class="line">Connection: Keep-Alive  </span><br><span class="line">Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; </span><br><span class="line">NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-</span><br><span class="line">FxlRugatx63JLv7CWMD6UB_O_r  </span><br><span class="line"></span><br><span class="line">hl=zh-CN&amp;source=hp&amp;q=domety</span><br></pre></td></tr></table></figure>
<p>可以看到，POST方式请求行中不包含数据字符串，这些数据保存在”请求内容”部分，各数据之间也是使用”&amp;”符号隔开。POST方式大多用于页面的表单中。因为POST也能完成GET的功能，因此多数人在设计表单的时候一律都使用POST方式，其实这是一个误区。GET方式也有自己的特点和优势，我们应该根据不同的情况来选择是使用GET还是使用POST。</p>
<h4 id="HEAD-方法"><a href="#HEAD-方法" class="headerlink" title="HEAD 方法"></a>HEAD 方法</h4><p>请求服务器返回响应头部，不返回实体。这就是和GET 方法的区别。</p>
<p>HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。</p>
<h4 id="GET-请求的标准格式"><a href="#GET-请求的标准格式" class="headerlink" title="GET 请求的标准格式"></a>GET 请求的标准格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /develop/rfc/default.htm HTTP/1.1</span><br><span class="line">Host: man.chinaunix.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>
<p>请求行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /develop/rfc/default.htm HTTP/1.1</span><br></pre></td></tr></table></figure></p>
<p>请求头部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Host: man.chinaunix.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure></p>
<h4 id="用POST上传文件"><a href="#用POST上传文件" class="headerlink" title="用POST上传文件"></a>用POST上传文件</h4><h5 id="PHP文件上传代码"><a href="#PHP文件上传代码" class="headerlink" title="PHP文件上传代码"></a>PHP文件上传代码</h5><p>fileupload.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;fileupload.php&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; name=&quot;uploadfile&quot;&gt;uploadfile：&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;&lt;br&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;upload&quot; /&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure></p>
<p>fileupload.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">move_uploaded_file($_FILE[&apos;file&apos;][&apos;tmp_name&apos;],$upfile[&apos;name&apos;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<h5 id="java文件上传代码"><a href="#java文件上传代码" class="headerlink" title="java文件上传代码"></a>java文件上传代码</h5><p>uploadfile.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form name=get method=post&gt;</span><br><span class="line">服务端地址&lt;input name=url size=110 type=text&gt;  &lt;br&gt;&lt;br&gt;&lt;textarea name=t rows=20 cols=120&gt;</span><br><span class="line">你提交的代码&lt;/textarea&gt;&lt;br&gt;</span><br><span class="line">保存成的文件名：&lt;input name=f size=30 value=shell.jsp&gt;</span><br><span class="line">&lt;input type=button onclick=&quot;javascript:get.action=document.get.url.value;get.submit()&quot; value=提交&gt; &lt;/form&gt;</span><br></pre></td></tr></table></figure></p>
<p>uploadfile.jsp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%if(request.getParameter(&quot;f&quot;)!=null)(new java.io.FileOutputStream(application.getRealPath(&quot;/&quot;)+request.getParameter(&quot;f&quot;))).write(request.getParameter(&quot;t&quot;).getBytes());%&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="HTTP1-1-新增的请求方法"><a href="#HTTP1-1-新增的请求方法" class="headerlink" title="HTTP1.1 新增的请求方法"></a>HTTP1.1 新增的请求方法</h4><h5 id="HTTP1-1-新增了五种请求方法：-OPTIONS-PUT-DELETE-TRACE-和-CONNECT-方法的基本概念"><a href="#HTTP1-1-新增了五种请求方法：-OPTIONS-PUT-DELETE-TRACE-和-CONNECT-方法的基本概念" class="headerlink" title="HTTP1.1 新增了五种请求方法： OPTIONS, PUT, DELETE,TRACE 和 CONNECT 方法的基本概念"></a>HTTP1.1 新增了五种请求方法： OPTIONS, PUT, DELETE,TRACE 和 CONNECT 方法的基本概念</h5><h6 id="OPTIONS-方法"><a href="#OPTIONS-方法" class="headerlink" title="OPTIONS 方法"></a>OPTIONS 方法</h6><p>没有找到合适的测试<br>OPTIONS它用于获取当前URL所支持的方法。若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。</p>
<pre><code>1、获取服务器支持的HTTP请求方法；也是黑客经常使用的方法。

2、用来检查服务器的性能。例如：AJAX进行跨域请求时的预检，需要向另外一个域名的资源发送一个HTTP OPTIONS请求头，用以判断实际发送的请求是否安全。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS / HTTP/1.1</span><br><span class="line">Host: www.myh0st.cn</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.3; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>
<h6 id="PUT-方法"><a href="#PUT-方法" class="headerlink" title="PUT 方法"></a>PUT 方法</h6><p>向指定资源位置上传其最新内容。<br>没找到合适的测试</p>
<h6 id="DELETE-方法"><a href="#DELETE-方法" class="headerlink" title="DELETE 方法"></a>DELETE 方法</h6><p>请求服务器删除Request-URI所标识的资源。<br>没有找到合适的测试</p>
<h6 id="TRACE-方法"><a href="#TRACE-方法" class="headerlink" title="TRACE 方法"></a>TRACE 方法</h6><p>回显服务器收到的请求，主要用于测试或诊断。</p>
<h6 id="CONNECT-方法"><a href="#CONNECT-方法" class="headerlink" title="CONNECT 方法"></a>CONNECT 方法</h6><p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p>
<h2 id="HTTP-的状态码"><a href="#HTTP-的状态码" class="headerlink" title="HTTP 的状态码"></a>HTTP 的状态码</h2><h3 id="HTTP-状态码的分类"><a href="#HTTP-状态码的分类" class="headerlink" title="HTTP 状态码的分类"></a>HTTP 状态码的分类</h3><h4 id="HTTP-状态码规范"><a href="#HTTP-状态码规范" class="headerlink" title="HTTP 状态码规范"></a>HTTP 状态码规范</h4><p><a href="http://blog.csdn.net/diandianxiyu_geek/article/details/50373195" target="_blank" rel="noopener">HTTP 状态码规范</a></p>
<h4 id="HTTP-状态码的作用"><a href="#HTTP-状态码的作用" class="headerlink" title="HTTP 状态码的作用"></a>HTTP 状态码的作用</h4><p>获取请求的返回结果和原因</p>
<h4 id="常见的-HTTP-状态码"><a href="#常见的-HTTP-状态码" class="headerlink" title="常见的 HTTP 状态码"></a>常见的 HTTP 状态码</h4><pre><code>1**     信息，服务器收到请求，需要请求者继续执行操作

100     Continue     继续。客户端应继续其请求
101     Switching Protocols     切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议


2**     成功，操作被成功接收并处理

200     OK     请求成功。一般用于GET与POST请求
201     Created     已创建。成功请求并创建了新的资源
202     Accepted     已接受。已经接受请求，但未处理完成
203     Non-Authoritative Information     非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本
204     No Content     无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档
205     Reset Content     重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域
206     Partial Content     部分内容。服务器成功处理了部分GET请求


3**     重定向，需要进一步的操作以完成请求

300     Multiple Choices     多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择
301     Moved Permanently     永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
302     Found     临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
303     See Other     查看其它地址。与301类似。使用GET和POST请求查看
304     Not Modified     未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
305     Use Proxy     使用代理。所请求的资源必须通过代理访问
306     Unused     已经被废弃的HTTP状态码
307     Temporary Redirect     临时重定向。与302类似。使用GET请求重定向


4**     客户端错误，请求包含语法错误或无法完成请求

400     Bad Request     客户端请求的语法错误，服务器无法理解
401     Unauthorized     请求要求用户的身份认证
402     Payment Required     保留，将来使用
403     Forbidden     服务器理解请求客户端的请求，但是拒绝执行此请求
404     Not Found     服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面
405     Method Not Allowed     客户端请求中的方法被禁止
406     Not Acceptable     服务器无法根据客户端请求的内容特性完成请求
407     Proxy Authentication Required     请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权
408     Request Time-out     服务器等待客户端发送的请求时间过长，超时
409     Conflict     服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突
410     Gone     客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置
411     Length Required     服务器无法处理客户端发送的不带Content-Length的请求信息
412     Precondition Failed     客户端请求信息的先决条件错误
413     Request Entity Too Large     由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息
414     Request-URI Too Large     请求的URI过长（URI通常为网址），服务器无法处理
415     Unsupported Media Type     服务器无法处理请求附带的媒体格式
416     Requested range not satisfiable     客户端请求的范围无效
417     Expectation Failed     服务器无法满足Expect的请求头信息


5**     服务器错误，服务器在处理请求的过程中发生了错误

500     Internal Server Error     服务器内部错误，无法完成请求
501     Not Implemented     服务器不支持请求的功能，无法完成请求
502     Bad Gateway     充当网关或代理的服务器，从远端服务器接收到了一个无效的请求
503     Service Unavailable     由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中
504     Gateway Time-out     充当网关或代理的服务器，未及时从远端服务器获取请求
505     HTTP Version not supported     服务器不支持请求的HTTP协议的版本，无法完成处理
</code></pre><h4 id="python获取HTTP-请求状态码"><a href="#python获取HTTP-请求状态码" class="headerlink" title="python获取HTTP 请求状态码"></a>python获取HTTP 请求状态码</h4><p>python3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">res=requests.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line">print(res.status_code)</span><br></pre></td></tr></table></figure></p>
<h2 id="HTTP-协议响应头信息"><a href="#HTTP-协议响应头信息" class="headerlink" title="HTTP 协议响应头信息"></a>HTTP 协议响应头信息</h2><h3 id="HTTP-响应头的含义"><a href="#HTTP-响应头的含义" class="headerlink" title="HTTP 响应头的含义"></a>HTTP 响应头的含义</h3><h4 id="常见的-HTTP-响应头和请求头"><a href="#常见的-HTTP-响应头和请求头" class="headerlink" title="常见的 HTTP 响应头和请求头"></a>常见的 HTTP 响应头和请求头</h4><p><a href="https://www.cnblogs.com/honghong87/articles/6941436.html" target="_blank" rel="noopener">常见的HTTP 响应头和请求头</a></p>
<h4 id="HTTP-响应头的类型"><a href="#HTTP-响应头的类型" class="headerlink" title="HTTP 响应头的类型"></a>HTTP 响应头的类型</h4><p><a href="http://www.runoob.com/http/http-header-fields.html" target="_blank" rel="noopener">HTTP 响应头类型</a></p>
<h2 id="HTTP-协议中的-URL"><a href="#HTTP-协议中的-URL" class="headerlink" title="HTTP 协议中的 URL"></a>HTTP 协议中的 URL</h2><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息<br>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：<br><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name" target="_blank" rel="noopener">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a><br>从上面的URL可以看出，一个完整的URL包括以下几部分：</p>
<h4 id="1-协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“-”为分隔符"><a href="#1-协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“-”为分隔符" class="headerlink" title="1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符"></a>1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符</h4><h4 id="2-域名部分：该URL的域名部分为“www-aspxfans-com”。一个URL中，也可以使用IP地址作为域名使用"><a href="#2-域名部分：该URL的域名部分为“www-aspxfans-com”。一个URL中，也可以使用IP地址作为域名使用" class="headerlink" title="2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用"></a>2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</h4><h4 id="3-端口部分：跟在域名后面的是端口，域名和端口之间使用“-”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口"><a href="#3-端口部分：跟在域名后面的是端口，域名和端口之间使用“-”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口" class="headerlink" title="3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口"></a>3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</h4><h4 id="4-虚拟目录部分：从域名后的第一个“-”开始到最后一个“-”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“-news-”"><a href="#4-虚拟目录部分：从域名后的第一个“-”开始到最后一个“-”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“-news-”" class="headerlink" title="4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”"></a>4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</h4><h4 id="5-文件名部分：从域名后的最后一个“-”开始到“？”为止，是文件名部分，如果没有“-”-则是从域名后的最后一个“-”开始到“-”为止，是文件部分，如果没有“？”和“-”，那么从域名后的最后一个“-”开始到结束，都是文件名部分。本例中的文件名是“index-asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名"><a href="#5-文件名部分：从域名后的最后一个“-”开始到“？”为止，是文件名部分，如果没有“-”-则是从域名后的最后一个“-”开始到“-”为止，是文件部分，如果没有“？”和“-”，那么从域名后的最后一个“-”开始到结束，都是文件名部分。本例中的文件名是“index-asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名" class="headerlink" title="5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名"></a>5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</h4><h4 id="6-锚部分：从“-”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分"><a href="#6-锚部分：从“-”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分" class="headerlink" title="6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分"></a>6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</h4><p>所以注入SQL语句的时候，需要将#进行url编码，否则会被当成锚点处理。</p>
<h4 id="7-参数部分：从“？”开始到“-”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID-5-amp-ID-24618-amp-page-1”。参数可以允许有多个参数，参数与参数之间用“-amp-”作为分隔符。"><a href="#7-参数部分：从“？”开始到“-”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID-5-amp-ID-24618-amp-page-1”。参数可以允许有多个参数，参数与参数之间用“-amp-”作为分隔符。" class="headerlink" title="7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。"></a>7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</h4><h6 id="（原文：http-blog-csdn-net-ergouge-article-details-8185219-）"><a href="#（原文：http-blog-csdn-net-ergouge-article-details-8185219-）" class="headerlink" title="（原文：http://blog.csdn.net/ergouge/article/details/8185219 ）"></a>（原文：<a href="http://blog.csdn.net/ergouge/article/details/8185219" target="_blank" rel="noopener">http://blog.csdn.net/ergouge/article/details/8185219</a> ）</h6><h3 id="URL和URI的区别"><a href="#URL和URI的区别" class="headerlink" title="URL和URI的区别"></a>URL和URI的区别</h3><p>URI，是(uniform resource identifier)，统一资源标识符，用来唯一的标识一个资源。</p>
<pre><code>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的
URI一般由三部组成：
①访问资源的命名机制
②存放资源的主机名
③资源自身的名称，由路径表示，着重强调于资源。
URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。
</code></pre><p>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。</p>
<pre><code>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。
URL一般由三部组成：
①协议(或称为服务方式)
②存有该资源的主机IP地址(有时也包括端口号)
③主机资源的具体地址。如目录和文件名等
</code></pre><p>URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。</p>
<p>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。</p>
<pre><code>URL和URN都是一种URI。
笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。
这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。
</code></pre><p>通常来说，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。<br>URI类不包含任何访问资源的方法，它唯一的作用就是解析。<br>相反的是，URL类可以打开一个到达资源的流。</p>
<h2 id="HTTP2-0-新事物"><a href="#HTTP2-0-新事物" class="headerlink" title="HTTP2.0 新事物"></a>HTTP2.0 新事物</h2><p><a href="http://www.mamicode.com/info-detail-1199706.html" target="_blank" rel="noopener">HTTP2.0 那些事</a></p>
<h2 id="HTTP-XST攻击与trace方法"><a href="#HTTP-XST攻击与trace方法" class="headerlink" title="HTTP XST攻击与trace方法"></a>HTTP XST攻击与trace方法</h2><pre><code>绕过http-only 对XSS攻击的限制
TRACE 请求会让服务器返回请求内容。
</code></pre><p>xst主要是使用http的trace方法，该方法会返回浏览器发给服务器的所有请求信息，但该方法不能带body，主要是利于debug。<br>现在前端后端都做了很多xst攻击的措施，很难在浏览器端发起trace请求了，所以只能用fiddler模拟一下，服务器是wamp，支持trace方法。</p>
<p>该攻击主要是在网站存在xss漏洞但设置了cookie的httponly属性的时候结合trace方法进行攻击。如果某网站存在xss漏洞，那比如用户点击a标签会执行一段脚本，那么该脚本可以异步发起一个trace请求，因为是同域，所以会带上cookie，然后服务器会把浏览器请求的信息全部返回来，其中包括cookie，我们可以在回调函数里解析然后上传到我们的服务器上去。</p>
<h2 id="使用python-requests库花式发送http请求"><a href="#使用python-requests库花式发送http请求" class="headerlink" title="使用python requests库花式发送http请求"></a>使用python requests库花式发送http请求</h2><p>（如果使用python的比较底层的HTTP请求库还能fuzzing）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">#只支持这五种</span><br><span class="line">requests.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line">requests.post(&quot;https://www.baidu.com&quot;)</span><br><span class="line">requests.put(&quot;https://www.baidu.com&quot;)</span><br><span class="line">requests.delete(&quot;https://www.baidu.com&quot;)</span><br><span class="line">requests.options(&quot;https://www.baidu.com&quot;)</span><br></pre></td></tr></table></figure></p>
<h2 id="Web-DAV"><a href="#Web-DAV" class="headerlink" title="Web DAV"></a>Web DAV</h2><h5 id="（Web-based-Distributed-Authoring-and-Versioning）"><a href="#（Web-based-Distributed-Authoring-and-Versioning）" class="headerlink" title="（Web-based Distributed Authoring and Versioning）"></a>（Web-based Distributed Authoring and Versioning）</h5><p>一句话原理就是，服务器允许put方法，相当与有了写权限．<br><a href="http://blog.csdn.net/u014270687/article/details/45798227" target="_blank" rel="noopener">Web Dav的安全配置相关与漏洞利用</a></p>
<h4 id="kali中有-dave和davtest-两个工具利用dav漏洞，python也可以，不必执着于某个工具，达到目的就好"><a href="#kali中有-dave和davtest-两个工具利用dav漏洞，python也可以，不必执着于某个工具，达到目的就好" class="headerlink" title="kali中有 dave和davtest 两个工具利用dav漏洞，python也可以，不必执着于某个工具，达到目的就好"></a>kali中有 dave和davtest 两个工具利用dav漏洞，python也可以，不必执着于某个工具，达到目的就好</h4><h2 id="CRLF注入攻击"><a href="#CRLF注入攻击" class="headerlink" title="CRLF注入攻击"></a>CRLF注入攻击</h2><p>CRLF就是\r\n，也就是响应头的分割符<br>一句话原理就是，web程序使用了用户输入作为相应头，且过滤不严，导致我们可以注入CRLF来分割http响应．</p>
<p>几个例子</p>
<p><a href="http://blog.csdn.net/gstormspire/article/details/8183598" target="_blank" rel="noopener">http://blog.csdn.net/gstormspire/article/details/8183598</a><br><a href="http://blog.csdn.net/mgxcool/article/details/73028346" target="_blank" rel="noopener">http://blog.csdn.net/mgxcool/article/details/73028346</a><br><a href="http://blog.csdn.net/rainZuoShao/article/details/9088575" target="_blank" rel="noopener">http://blog.csdn.net/rainZuoShao/article/details/9088575</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
        <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block home">
    <link itemprop="mainEntityOfPage" href="http://hl0rey.github.io/2018/02/03/proxychains配置详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hl0rey's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2018/02/03/proxychains配置详解/" class="post-title-link" itemprop="url">proxychains配置详解</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建于：2018-02-03 21:27:08 / 更新于：22:08:49" itemprop="dateCreated datePublished" datetime="2018-02-03T21:27:08+08:00">2018-02-03</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tools/" itemprop="url" rel="index"><span itemprop="name">tools</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>proxychains是一个支持　http socks4 socks5 代理的强力的代理工具（支持身份认证）．&apos;chains&apos;这个词是关键，支持代理链．现在已经有新版（proxychains ng (new generation)，增加了一些功能．
</code></pre><h3 id="支持的代理类型"><a href="#支持的代理类型" class="headerlink" title="支持的代理类型"></a>支持的代理类型</h3><pre><code>http, socks4, socks5    
</code></pre><h5 id="支持的身份认证方式"><a href="#支持的身份认证方式" class="headerlink" title="支持的身份认证方式"></a>支持的身份认证方式</h5><pre><code>http基本身份认证  socks用户名/密码认证
</code></pre><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><pre><code>proxychains xxxx
</code></pre><p>xxxx　的流量就走代理了．</p>
<h3 id="配置文件位置"><a href="#配置文件位置" class="headerlink" title="配置文件位置"></a>配置文件位置</h3><pre><code>Proxychains 依照下面的顺序来寻找配置文件：
首先在当前目录下找：
./proxychains.conf
再在用户家目录下找
$(HOME)/.proxychains/proxychains.conf
系统配置文件目录：
/etc/proxychains.conf 
</code></pre><h3 id="配置项详解"><a href="#配置项详解" class="headerlink" title="配置项详解"></a>配置项详解</h3><h4 id="代理类型"><a href="#代理类型" class="headerlink" title="代理类型"></a>代理类型</h4><p>dynamic_chain　自动跳过死代理<br>strict_chain　每个代理都使用，不管死活<br>random_chain 随便挑着代理用　（chain_len　是配置每次用的代理个数）</p>
<h4 id="代理dns请求"><a href="#代理dns请求" class="headerlink" title="代理dns请求"></a>代理dns请求</h4><p>proxy_dns</p>
<h4 id="跳过本地地址（proxychains-ng-目前值得一提的功能，ng才支持）"><a href="#跳过本地地址（proxychains-ng-目前值得一提的功能，ng才支持）" class="headerlink" title="跳过本地地址（proxychains ng 目前值得一提的功能，ng才支持）"></a>跳过本地地址（proxychains ng 目前值得一提的功能，ng才支持）</h4><p>localnet 127.0.0.0/255.0.0.0</p>
<h4 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h4><p>tcp_read_time_out 15000<br>tcp_connect_time_out 8000</p>
<h4 id="代理列表"><a href="#代理列表" class="headerlink" title="代理列表"></a>代理列表</h4><h5 id="代理列表开始的标记"><a href="#代理列表开始的标记" class="headerlink" title="代理列表开始的标记"></a>代理列表开始的标记</h5><p>[ProxyList]</p>
<h5 id="代理格式"><a href="#代理格式" class="headerlink" title="代理格式"></a>代理格式</h5><pre><code>type  host  port [user pass]
每一项配置用　tab 或者空格　隔开
</code></pre><h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5><pre><code>socks5    192.168.67.78    1080    lamer    secret
http    192.168.89.3    8080    justu    hidden
socks4    192.168.1.49    1080
http    192.168.39.93    8080    
</code></pre>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </div>
  
  
  
  </article>

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Vorherige Seite"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Nächste Seite"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">博主</p>
  <div class="site-description" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">博主</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.5.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/muse.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

</body>
</html>
